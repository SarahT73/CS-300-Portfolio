# CS-300-Portfolio

### What was the problem you were solving in the projects for this course?
> This course was focused on the Computer Science department at ABCU and their desire for an application to assist with advising. The program needs to read a list of courses and their prerequisites from a file, and be able to output the entire list or output the prerequisites of a specific course that is searched for within the program.

### How did you approach the problem? Consider why data structures are important to understand.
> Throughout the course we looked at three different data structures, including vectors, Hash Maps, and a Binary Search Tree. I approached the problem by using a Binary Search Tree because as the course list gains more and more courses, it will be faster to search through a binary search tree than a vector or hash method. Because the courses have numbers and can be ordered, a binary search tree can be searched quickly based on compareing the values of course numbers to each other, providing an efficient program.

### How did you overcome any roadblocks you encountered while going through the activities or project?
> I had not worked with hash maps or binary search trees prior to this course, so I had to do some research in the beginning of the course to understand how to approach the assignments for the course. I overcame any issues in the code and pseudocode that I had by researching and trying to understand the core concepts of the data structures we were studying in order to build upon those concepts to complete each project.

### How has your work on this project expanded your approach to designing software and developing programs?
> This assignment required us to write pseudocode before actually writing any code, which I have done before, but don't practice it as regularly as I should. It was nice to have to practice this way again and have a basis when I went to write the code. I had forgotten how nice it was to work out the details with pseudocode and then just make adjustments when writing the program itself. 

### How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
> Nothing has changed about how I write programs that are maintainable, readable, and adaptable. I always try to follow a consistent style of code and comments, keeping functions and classes focused on single tasks, and keeping the entire program modular so that maintaining the code is easier later on.
